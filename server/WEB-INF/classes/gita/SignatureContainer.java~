/*
 * SignatureContainer.java
 *
 * Created on 8 February 2005, 17:59
 */

package gita;

import zone.Rectangle;
import zone.Point;
import zone.HTMLwriter;
import java.lang.Math;
import java.lang.Float;
import java.util.LinkedList;
import gita.*;

/**
 * Extension of StrokeGroupInfo class for a group of strokes associoated with a particular users signature. This
 * structure contains information gleaned from one particular instance of a users (apparent) signature.
 * <ul>
 * <li>linked list of strokes composing the signature
 * <li>composite minimal bounding box for these strokes. Currently this is worked out by
 * the cartesian bounding boxes... which is not rotationally invariant. would be nice to
 * have a rotationally invariant way of looking at this.
 * </ul>
 *<p>
 * A signature can consist of an arbitrary number of Strokes, typically not consistent for a particular
 * users signature. Many of these strokes are noise e.g. dots. Sometimes additional strokes are
 * generated by inconsistent pressure on the pen. Some people just do it that way.
 *<p>
 * Signature training data is contained in a single svg document in one of two ways
 * <ul>
 * <li>as a box each enclosing the strokes of signature training data
 *  boxes are svg paths with an attribute in the gita namespace, gita:vastd="person-id", where
 *  person-id is a person who would be presumably logged with the system somewhere
 * <li>as an svg group with the gita:vastd="person-id" attribute. All strokes in such a group constitute
 * a signature.
 * </ul>
 *<p>
 * Multiple training signatures are allowed for a single document in any combination of the
 * two methods described above.
 *<p>
 * It is currently assumed that only one user inputs signature data in a single document
 *
 * @see Stroke
 * @see StrokeGroup
 * @see StrokeGroupInfo
 * @author David Karla
 * @since you asked
 */
public class SignatureContainer extends StrokeGroupInfo
{

    /**
     * How can I count the ways that I enumerate the clumps. Probably on the fingers of one hand,
     * but until I get a really good consistent way to do it, I'll count any possible ways in
     * this enum
     */
    public enum ClumpingMethod
    {
        /** no particular clumping method */          None,
        /** clump segments according to their sign */ Sign,
        /** clump stroke segments heuristically */    Heuristic
    }
    
    /**
     * Creates a new instance of SignatureContainer
     *  @param uid the name of the person for whom this is the signature. Ideally this will correspond to
     *   an entry in a secure database of users of the system
     *  @param g the group of strokes for which this is the StrokeGroupInfo member
     */
    public SignatureContainer(String uid, StrokeGroup g)
    {
        super(g);
        userId = new String(uid);
        signatureBounds = new Rectangle();
    }

    /**
     * performs all the necessary feature calculations for this signature, storing the relevant results in
     * data members of this class.
     *<p>
     * calculations include
     * <ul>
     *  <li>a bounding box for all the strokes of the signature
     *  <li>dropping of small and short strokes from the group
     *  <li>creation of a single encompassing stroke for all stroke data. The composite single stroke
     *      is composed of all un-dropped strokes in the order they are received (and presumably written)
     *  <li>calculation of features of the composite signature: normalised segment lengths, tangent angles,
     *      curvature, sin vector, cos vector, dl*sin vector, dl*cos vector, derivative of curvature
     *  <li>calculation of a clumped form of this signature, associating adjacent segments which form
     *      larger scale graphical features
     *  <li>calculation of the signature relative bounding box and mean for each stroke in the signature
     * </ul>
     *
     * @param http HTMLwriter for diagnostic output
     * @see StrokeGroup
     * @see StrokeGroupInfo
     * @see SignatureStroke
     * @see StrokeInfo
     * @see Stroke
     */
    public void CalculateFeatures(HTMLwriter http)
    {
        signatureBounds.left = signatureBounds.top = Float.POSITIVE_INFINITY;
        signatureBounds.right = signatureBounds.bottom = Float.NEGATIVE_INFINITY;
       
        for (int i=0; i<group.nStrokes; i++) {
            Stroke  s = group.get(i);
            SignatureStroke sig = null;
            // ensure that the info for this stroke is appropriate to a stroke in a signature
            if (s.info == null || s.info.getClass() != SignatureStroke.class) {
                s.info = sig = new SignatureStroke(s); 
            } else {
                sig = (SignatureStroke) s.info;
            }
            try {
                sig.CalculateFeatures(http);
                if (s.bounds.left < signatureBounds.left) {
                    signatureBounds.left = s.bounds.left;
                }
                if (s.bounds.top < signatureBounds.top) {
                    signatureBounds.top = s.bounds.top;
                }
                if (s.bounds.right > signatureBounds.right) {
                    signatureBounds.right = s.bounds.right;
                }
                if (s.bounds.bottom > signatureBounds.bottom) {
                    signatureBounds.bottom = s.bounds.bottom;
                }
/*
 * delete spurious points that won't yield much information, and won't be that useful
 * to a curve matching algorithm.
 * these could yield useful positional data, however, and it might be
 * a good idea to extract that before chucking them. later
 */
                if (sig.dL.length <= nSmallStrokeSamples &&
                       s.bounds.diagLen() < smallStrokeSize) {
                    http.printbr("Out, out, damned dot! len="+sig.dL.length);
                    s.info = sig = null;
                }
            } catch (Cow c) {
/*
 * at this point, should try to remove this stroke from contention
 * it's almost certainly a single point or degenerate stroke that won't tell us anything.
 * if something worse is broken, we'll probably stuff up really badly a bit further down the track
 */
                String msg = c.getMessage();
                http.printbr("Analysis throws a cow! len="+sig.dL.length+":"+(msg!=null?msg:"cause unspecified"));
                s.info = sig = null;
            }
        }

/*
 * get rid of strokes we have decided to drop
 */
        for (int i=group.nStrokes-1; i>=0; i--) {
            Stroke s = group.get(i);
            if (s.info == null) {
                http.printbr("<B>Removing stroke...</B>");
                group.nStrokes--;
                group.strokes.remove(i);
            }
        }
/*
 * create a single uberstroke that contains all the bits and peaces of the composing strokes
 * will have at most 'totalSamples' samples, and maybe a couple less if there's a freaky intersection
 */
        int     totalSamples = 0;
        for (Stroke s: group.strokes) {
                // info is guaranteed set to a SignatureStroke by code at start of this method
            SignatureStroke sig = (SignatureStroke) s.info;
            totalSamples += sig.lfData.length;
        }
        uberSig = new SignatureSample[totalSamples];
        subStrokeUberOffset = new int[group.nStrokes];
        nSigSample = 0;
        Point       prev = null;
        int         ssCnt = 0;
        for (Stroke s: group.strokes) {
//            http.printbr("lf data "+s.sigStroke.lfData.length+", nsam "+s.nSample);
            SignatureStroke sig = (SignatureStroke) s.info;
            Point   p = sig.lfData[0];
            boolean firstInserted = false;
            for (int i=0; i<sig.lfData.length; i++) {
                p = sig.lfData[i];
                if (!p.equals(prev)) {  // just in case the data hasn't been filtered
                    uberSig[nSigSample] = new SignatureSample(p);
                    if (!firstInserted) {
                        uberSig[nSigSample].keypoint = 1;
                        subStrokeUberOffset[ssCnt++] = nSigSample;
                        firstInserted = true;
                    }
                    nSigSample++;
                    prev = p;
                }
            }
        }
/*
 * work out the normalized arklength components
 */
        sigdL = InkFilta.SegmentLengths(uberSig.length, uberSig);
        sigdL = InkFilta.NormalizeLengthVector(sigdL);
        float arklen = 0;
        float dl[] = new float[sigdL.length];
        uberSig[0].arklen = 0;
        dl[0] = 0;
        for (int i=1; i<sigdL.length; i++) {
            arklen += sigdL[i];
            dl[i] = sigdL[i] + sigdL[i-1];
            uberSig[i].arklen = arklen;
        }
/*
 * calculate all the features for this uber beast...
 * chances are we don't need any info at all from the components, and perhaps
 * significant spatial stuff will be encoded in the uber details
 */ 
        try {
            sigTangle = InkFilta.DelTheta(uberSig.length, uberSig, false);
            sigCos = new float[sigTangle.length];
            sigSin = new float[sigTangle.length];
            sigA = new float[sigTangle.length];
            sigB = new float[sigTangle.length];
            segmentType = new Stroke.SegmentType[sigTangle.length];
            segmentScore = new float[sigTangle.length];
            
            for (int i=0; i<sigTangle.length; i++) {
                sigCos[i] = (float)Math.cos(sigTangle[i]);
                sigSin[i] = (float)Math.sin(sigTangle[i]);
                sigA[i] = sigdL[i] * sigCos[i];
                sigB[i] = sigdL[i] * sigSin[i];
                segmentScore[i] = (float) Math.abs(sigTangle[i]/Math.PI);
                segmentType[i] = Stroke.classifySegment(segmentScore[i]); 
            }
            
/*
 * calculate derivative and second derivative
 */
            sigdTangledL = InkFilta.DyDx(sigTangle, dl);
            sigd2TangledL2 = new float[sigdTangledL.length];
            float[] d2 = new float[sigTangle.length];
            d2[0] = 0;
            sigTangle[0] = 0;
            for (int i=1; i<sigd2TangledL2.length; i++) {
                d2[i] = sigdTangledL[i] - sigdTangledL[i-1];
            }

            sigd2TangledL2 = InkFilta.DyDx(d2, dl);
/*
 * heuristic data clumping
 */
            nClump = 1;
            clumpedTheta = new float[sigTangle.length];
            clumpedL = new float[sigTangle.length];
            clumpedArk = new float[sigTangle.length];
            clumpLabel = new int[sigTangle.length];

            switch (clumpingMethod) {
                case None: {
                    break;
                }
                
                case Sign:        {
                    clumpedTheta[0] = 0;
                    clumpedL[0] = 0;
                    clumpedArk[0] = clumpedArk[1] = 0;
                    clumpLabel[0] = 0;
                    int clumpSgn = 0;
                    for (int i=1; i<sigTangle.length; i++) {
                        if (sigTangle[i] == 0 || clumpSgn == sgc(sigTangle[i])) {
                            clumpedTheta[nClump-1] += sigTangle[i];
                            clumpedL[nClump-1] += sigdL[i];
                            clumpedArk[nClump] += sigdL[i];
                            clumpLabel[nClump-1] = i;
            //                http.printbr(i+" clump add "+nClump+" "+sigTangle[i]+" "+sigdL[i]+" = "+clumpedTheta[nClump-1]+" "+clumpedArk[nClump-1]+" "+clumpedL[nClump-1]);
                        } else {
                            clumpedTheta[nClump] = sigTangle[i];
                            clumpedL[nClump] = sigdL[i];
                            clumpedArk[nClump+1] = clumpedArk[nClump]+sigdL[i];
                            nClump++;
                            clumpSgn = sgc(sigTangle[i]);
            //                http.printbr(i+" clump new "+nClump+" "+sigTangle[i]+" "+sigdL[i]+" = "+clumpedTheta[nClump-1]+" "+clumpedArk[nClump-1]+" "+clumpedL[nClump-1]);
                        }
                    }
                    break;
                }
            }
        } catch (Cow c) { 
            http.printbr("tangent angle calculation of uber signature throws a cow");
        }
/*
 * calculate bounding boxes relative to the minimum bounding box of the signature
 */
        float   h = signatureBounds.bottom - signatureBounds.top;
        float   w = signatureBounds.right - signatureBounds.left;
        for (int i=0; i<group.nStrokes; i++) {
            Stroke  s = group.get(i);
            SignatureStroke sig = (SignatureStroke) s.info;
            Rectangle   r = s.bounds, rr = sig.groupRelativeBounds;
            Point       m = s.mean, rm = sig.groupRelativeMean;
            
            rr.left = (r.left - signatureBounds.left)/w;
            rr.right = (r.right - signatureBounds.left)/w;
            rr.top = (r.top - signatureBounds.top)/h;
            rr.bottom = (r.bottom - signatureBounds.top)/h;
            
            rm.x = (m.x - signatureBounds.left)/w;
            rm.y = (m.y - signatureBounds.top)/h;
        }
    }
 
    /**
     * Display stored features to a html page
     * @param http a HTMLwriter attached to the print writer for html page display
     */
    public void DisplayFeatures(HTMLwriter http)
    {
        http.printbr("signature group");
        Rectangle rr = signatureBounds;
        http.printf("rect: %.3g %.3g %.3g %.3g\n", rr.left, rr.top, rr.right, rr.bottom);
        http.printbr("");
          
        http.printbr("uber stroke ");
        http.table(1);
        if (sigTangle != null) {
            http.tablerow("tangent angle", "%.3g", sigTangle);
        }
        if (sigA != null) {
            http.tablerow("tangent a", "%.3g", sigA);
        }
        if (sigB != null) {
            http.tablerow("tangent b", "%.3g", sigB);
        }
        if (segmentScore != null) {
            http.tablerow("segmentScore", "%.3g", segmentScore);
        }
        if (segmentType != null) {
            http.tablerow();
            http.tabledata();
            http.print("segment type");
            for (int j=1; j<segmentType.length; j++) {
                http.tabledata();
                http.printf("%s", segmentType[j]);
            }
        }
        if (sigdL != null) {
            http.tablerow("dL", "%.3g", sigdL);
        }
        if (sigdTangledL != null) {
            http.tablerow("curvature", "%.3g", sigdTangledL);
        }
        if (sigdL != null) {
            http.tablerow();
            http.tabledata();
            http.print("arc length");
            float   length = 0;
            for (int j=1; j<sigdL.length; j++) {
                length += sigdL[j];
                http.tabledata();
                http.printf("%.3g", length);
            }
        }
        if (clumpedTheta != null) {
            http.tablerow("clump tang", "%.3g", clumpedTheta);
        }
        if (clumpedL != null) {
            http.tablerow("clump l", "%.3g", clumpedL);
        }
        if (clumpedArk != null) {
            http.tablerow("clump ark", "%.3g", clumpedArk);
        }
        http.closetag();
        for (int i=0; i<group.nStrokes; i++) {
            Stroke  s = group.get(i);
            if (s.info != null && s.info.getClass() == SignatureStroke.class) {
                SignatureStroke   sig = (SignatureStroke) s.info;
                
                http.printbr("stroke "+i);
                http.table(1);
                http.tablerow("tangent angle", "%.3g", sig.tangle);
                http.tablerow("dL", "%.3g", sig.dL);
                http.tablerow("curvature", "%.3g", sig.dTangledL);
                
                http.tablerow();
                http.tabledata();
                http.print("arc length");
                float length = 0;
                for (int j=1; j<sig.dL.length; j++) {
                    length += sig.dL[j];
                    http.tabledata();
                    http.printf("%.3g", length);
                }
                http.closetag();
                Rectangle  r = sig.groupRelativeBounds;
                Point      m = sig.groupRelativeMean;
                http.printf("mean: %.3g %.3g", m.x, m.y);
                http.printbr("");
                http.printf("rect: %.3g %.3g %.3g %.3g\n", r.left, r.top, r.right, r.bottom);
                http.printbr("");
            }
        }
        http.printbr("");
    }

    /**
     * First draft for clumping based on sign of angle. Gets a broad classification class for theta
     * for clumping purposes. Runs into the problem that extreme angles could be visually similar,
     * and yet be close to either +pi or -pi. Doesn't help much, either, where the sign is relatively
     * unchanged, and the features are variations in steepness of curvature of consistent sign.
     *
     * @param x the angle
     * @return +1 or -1 depending on the sign of x
     */
    short sgc(float x)
    {
        return (x >= 0)? (short)1 : (short)-1;
    }
   
///////////////////////////////////////////////////////////////////
// main data members
///////////////////////////////////////////////////////////////////
    /** the supposed user name that a signature belongs to. ideally used to look up a database for signature templates. */
    String              userId = null;  
    /** composite bounding box for the signature as a whole. the union of all the bounding boxes of composing strokes */
    Rectangle           signatureBounds = null; 
    
    /** total number of samples contained in the signature <= uberSig.length */
    int                 nSigSample = 0;
    /** composite stroke for all constituent strokes in signature. i.e. their union */
    SignatureSample[]   uberSig = null;
    /** index of all component strokes within the signature uber-stroke */
    int                 subStrokeUberOffset[] = null;   // index of composing strokes in the uberSig
    /** lengths of segments in a (theta,dL) representation of the composite signature */
    float[]             sigdL = null; 
    /** tangent angle in a (theta,dL) representation of the composite signature */
    float[]             sigTangle = null;
    /** cos tangent angle for the composite signature */
    float[]             sigCos = null;
    /** sin tangent angle for the composite signature */
    float[]             sigSin = null;
    /** dL * cos tangent angle for the composite signature */
    float[]             sigA = null; 
    /** dL * sin tangent angle for the composite signature */
    float[]             sigB = null;
    float[]             segmentScore = null;
    Stroke.SegmentType[]    segmentType = null;
    float[]             sigdTangledL = null;   // tangent angle derivative of the uber signature
    float[]             sigd2TangledL2 = null;   // tangent angle 2nd derivative of the uber signature
    
    /** number of clumps in the composite signature */
    int                 nClump = 0;
    /** total theta traversed through each clump */
    float[]             clumpedTheta = null;
    /** total dL traversed through each clump */
    float[]             clumpedL = null; 
    /** cumulative dL for each clump of the composite signature */
    float[]             clumpedArk = null;
    /** label of the principle turning point for each clump */
    int[]               clumpLabel = null; 
    
    /** particular clumping method used */
    ClumpingMethod      clumpingMethod = ClumpingMethod.None;
}
