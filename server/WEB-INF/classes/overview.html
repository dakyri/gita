<html>
<body>
 <p>Gita is a visual language processing sytem for digital ink data, such as that generated by the
 anoto pen device.
 Ideally, the system will take digital pen data from a variety of sources, and
 situations e.g. interface to a tablet pc, a digital whiteboard marker (mimio or such), or one
 of the alternative pen systems, as well as the various forms of the anoto system.
 <h2>Structural Overview</h2>
  <p>Gita is the instantiation of algorithms defined by the GIDA patent. It operates from inside a
  web server as a Java servlet. Extensive use is made of Java 5 features: enums, generics, and
  the new simpler syntax for manipulataing Collection classes. The servlet
  container currently used is Tomcat 5.5.7.
  <p>The implementation as a web service is not essential, and restricts the usefulness of the
  system for some applications where a local processor would be more useful. However, it does
  provide a clear path towards incorporating gita as an Anoto ASP, and is useful in any
  application where the system is integrated with on-line services. A browser front end also
  provides a quick, flexible, and portable interface, through the use of HTML and SVG.
  The use of Java greatly simplifies what would otherwise be a nightmare of dynamic
  allocation and garbage collection.
  <p>Many of the difficulties faced in developing gita rest in the current limitations of the
  Anoto pen device that has been used in the prototype. Other pen/tablet systems, or a full
  commercial developers kit for Anoto, would alleviate some of these issues.
   <ul>
    <li>The Anoto pen dow not do a streamed real time transfer of data at all. Input from it is
     strictly based on the transmission of a complete page. This restriction applies across the
     board, until (unlikely!) Anoto shift from their current restrictive licensing practices which
     requires their page based/server transmitted approach to implement security and licensing
     protocols. This is hardwired into the pen hardware, and requires a redesigned pen ASIC. Good
     luck getting them to do this. This limits use of the pen in many interactive applications where
     a pen would be the perfect thing. e.g. the original WBA whiteboard proposal from which this
     current project, gita, grew. Wouldn't it be nice to have the pen strokes displayed in real time
     as they go in? Backprojected onto a whiteboard screen, displayed in an epaper book ... the
     list of dreams goes on ...
    <li>The demo kit does not have access to timing information (the $10K developers kit does). Timing
     information would provide, I believe, better ways for extracting some of the analytical information
     that required by gita. For instance, sharp corners might well be highlighted be brief hesitations. Proving
     this would be an interesting, tricky, and pointless research project on how people write. For $10K
     you can test the theory. Even more useful is that the timing of a signature will probably provide
     better identity matching than pure geometry matching.
    <li>The demo kit does not have access to pressure information (the $10K developers kit does). It seems
     quite possible that access to the pen pressure information would enable a more accurate method
     for recognizing noise artifacts due to pen up and pen down in a stroke sample. Typically the
     ends of strokes have a random component due to the up and down pen motion, and momentum of the
     hand as it moves from stroke to stroke. This could be useful contextual information for indicating
     relatedness between strokes if there were an easier way to differentiate these artifacts. See
     <i>InkFilta.PenArtifactFilter</i>, which is currently responsible for doing this dirty work.
    <li>Full pen orientation information probably exists in the Anoto ASIC somewhere, as this would be
     needed to rectify distortions in the perceived dot pattern that are due to pen angle. The key Anoto
     patent mentions this in passing. Full pen orientation would open a whole new ball game in terms
     of modelling handdrawn strokes to graphics applications. Imagine the digital pen being used to model
     a paintbrush, a block of charcoal, or a pencil. How much fun would that be in Photoshop or Illustrator.
     This was at the core of a tracked whiteboard erasure system suggested by myself (dak) that didn't rip
     off the mimio approach (which was the approach suggested in the initial WBA proposal).
   </ul>
  <h3>Dataflow</h3>
   <p>This current implementation provides two alternate input formats into gita.
   <ul>
    <li>Anoto log files, as produced by the Anoto demo kit. These are typically uploaded automatically
        by the applet <i>Scrounger</i> which polls the Anoto dump directory, transmits anything useful
        it finds there, and then deletes it.
    <li>SVG files. These are directly uploaded via a browser form in the control frame. These are
        typically, but not necessarily, the results of prior runs of the system on Anoto log data.
   </ul>
   <p>All graphical output is via SVG, with additional annotations in a seperate XML namespace used to
   store gita's own deductions and intermediate results.
   <p>In the case of form upload input, HTML output from gita is directed straight to the display
    frame in the usual manner. When gita receives a http request from the scrounger applet, a temporary page is
    generated on the server, and gita's immediate response to the applet consists of a url to this page.
    This is necessary as the log data is typically too big to transmit via http GET, and must be POSTed
    instead. The java URLConnection, necessary for the transmission of POST data,
    is a direct connection to the applet, and assumes display is within the calling frame.
    This allows the applet to show the page in the main display frame via an AppletContext.showDocument call. 
    Gita presumes that if it receives a file upload, the connection was made from the right frame for
    output, and it can safely just send the HTML as its response, otherwise it sends a temporary URI.
   <br><br>
   <img src="dataflow.jpg" alt="*** error: image not found. please copy server/images/dataflow.jpg to Gita-build/dist/javadoc"/>
   <br><br><br><br>
  <h3>Components and modules</h3>
  <p>The most important classes and modules for the gita servlet are shown below. Classes that are
   principally functional components are shown in grey, classes that are colored light aqua are
   data structures passed between functional components.
   The distinction between components is slightly blurred.
   Most of the basic data structures encapsulate the low level
   operations needed by the functional components e.g. most of the mathematical operations
   used for feature recognition are encapsulated in the StrokeInfo structure. Most of gita's classes
   are not shown, as they are more specific forms of the basic functionalities shown below, or are
   packages of support functions e.g. InkFilta provides a lot of basic analytical functionality.
  <p>Classes shown in dotted balloons are yet to be fully specified.
  <p>The Demonstrator class embodies an alternate, once-off, mode of operation for Gita. If it
   succeeds in its intention, of impressing someone in a product demonstration of potential
   capabilities of gita, it should be promptly destroyed. It has some of the features and
   capacities of the CFR, CLPS, and GS, and follows the same data flow.
   <br><br>
   <img src="components.jpg" alt="*** error: image not found. please copy server/images/components.jpg to Gita-build/dist/javadoc"/>
   <br><br><br><br>
   <p>The principle data structure employed is the <i>Stroke</i> which encapsulates the positional (and hopefully
   one day the timing and pressure) samples that constitute a pen stroke. It is referred to by the <i>PageData</i>
   structure, which is equivalent to a "page" full of strokes, and also has grouping data which refers to the
   stroke data, in particular to how it appears in an SVG document. The stroke itself has an info structure, an extension of the abstract <i>StrokeInfo</i>
   depending on the kind of stoke that it is: this info contains all the basic feature calculation data for
   that stroke. Groups also have information structures which are an extension of the abstract <i>StrokeGroupInfo</i>.
   Results from analysis of features that impute some meaning into particular groups of strokes are returned
   via <i>Symbol</i> structures. The results of analysing a <i>PageData</i> would be a <i>SymbolList</i>
   structure. The <i>SymbolList</i> is a "fuzzy" structure in that it allows for the possibility of
   ambiguous, probabilistic chains of results. These chains may branch arbitrarily. The <i>SymbolList</i>
   will also contain a cache of geometric data and relationships for use by the parser, and will be
   a key element to the parse stack. Various relevant values for a <i>Symbol</i> appear in the
   symbol value structure, or a subclass thereof.
   <br><br>
   <img src="datastructures.jpg" alt="*** error: image not found. please copy server/images/datastructures.jpg to Gita-build/dist/javadoc"/>
   <br><br><br><br>
 <h2>Configuration</h2>
  <p>The current prototype implementation of <i>gita</i> can be reconfigured via two different
  mechanisms: server side, via servlet parameters, and internally, via preset constant variables
  in the class code.
  <h3>Server Configurations</h3>
   <p>Server side configuration is accomplished via the web.xml servlet configuration file. The Tomcat
   server passes these parameters to the main servlet class, gita, when it is run.
   <p>This is a more flexible method for adjusting the system. Ideally, all interesting parameters
   would be set this way, rather than via ad-hoc constants.
   <p>These parameters are most easily changed within Netbeans. The <i>web.xml</i> file is under
   "Configuration Files" in the project node for <i>Gita</i>. Editting this file in the IDE brings
   up a set of general configuration menus for web pages and servlets associated with the project
   (currently only just the one, servlet/gita). Relevant parameters are on the <i>Servlets</i> page,
   under the node <i>servlets/gita</i>. Parameters available here are:
   <ul>
    <li><b>project-base</b>. This gives the base directory within which the directories of temporarary
        web pages and processed svg output from the system are kept. Currently this is set to the
        servlet's class base.
    <li><b>gita-mode</b>. If this parameter has the value "demo", then the servlet is run in demo mode.
        In this mode, a seperate style sheet, "demo.css", is used instead of the default, all diagnostics
        are supressed, and the processed input is passed through the class gita.Demonstrator. In the
        default mode, the stylesheet "zone.css" is used, diagnostics are displayed, and a serious
        of lengthy analyses are performed and displayed.
   </ul>
  <h3>Internal Configurations</h3>
   <p>There are key configuration parameters that affect the low level operation of the system and
   recognisers kept as variables throughout the code for <i>gita</i>. Most of the numeric tolerances
   controlling recognizers are in <i>Tolerance.java</i>. (Please check Tolerance.java for further
   documentation, and the presence of any late-breaking numeric tuning variables).
   <p>In a more perfect world all this stuff would be a bit more centrally located, ideally in the
   web.xml configuration file. If you don't see this message, you'll know I found time to do this.
   Otherwise, why don't you give it a go...
   <p>In the file <i>Gita.java</i>
   <ul>
    <li><b>boolean generateTemporaryPage</b>. Forces gita to display html via the generation of temporary
        pages on the server rather than by the direct transmission of html data. This allows the client
        browser interface to display gita's results in different browser frames to that which made
        the call to the browser. This, in turn, allows gita's results to be viewed without reloading
        the Scrounger applet. If it's likely that the entity making the http request wants display
        in the frame making the request (i.e. business as usual), gita ignores this directive.
    <li><b>boolean mapFiltered</b>. True if we want to display the graphic results of contour
        filtering and resampling.
    <li><b>boolean mapTransforms</b>. True if we want to display any results of fourier transforms.
    <li><b>boolean drawResampledComparison</b> True if we want to display a comparison between raw
        and resampled paths.
    <li><b>boolean mapSignatures</b>. True if we want to display results of signature processing.
    <li><b>boolean displayTransformGraphs</b>. Tue if we want to display the graphic results of
        transforms of contour data.
    <li><b>boolean demoMode</b> Overriden by the web.xml parameter. Puts gita in demoMode.
    <li><b>File logDirectory</b> Overriden by the web.xml parameter. Directory used for storing
        generated files and svg pages
    <li><b>File tmpDirectory</b>Overriden by the web.xml parameter. Directory used for temporarily
        generated html pages.
    <li><b>float graphIte</b>. Display height in units of SVG coordinate space (ie pixels) of
        a transform graph
   </ul>
   <p>In the file <i>StrokeAlysis.java</i>
   <ul>
    <li><b>boolean displayTransformValues</b>. display results of transforms
    <li><b>boolean displayDerivativeValues</b>. display results for derivatives
    <li><b>boolean displayThetaValues</b>. display calculated theta values
    <li><b>boolean displaySampleValues</b>. display resampled values 
    <li><b>boolean displayRawContourValues</b>. display results of analyses of raw contour
    <li><b>boolean displayLengthenedContourValues</b>. display results of analyses of length filtered contour
    <li><b>boolean displayStraightenedContourValues</b>. display results of analyses of straightened contour
    <li><b>boolean displayEqualisedContourValues</b>. display results of analyses of contour resampled in equal lengths
    <li><b>boolean calculateTransforms</b>. do calculations of transforms of contours
   </ul>
   <p>In the file <i>Tolerance.java</i>
   <ul>
   <li><b>int nSmallStrokeSamples (default 4)</b>. number of samples in a stroke too small to worry about, used by <i>SignatureContainer</i>
   <li><b>float smallStrokeSize (default 3.0)</b>. size below which a stroke is too small to be of interest for a signature, used by <i>SignatureContainer</i>
    <li><b>float lengthThreshold (default 1.0)</b>. Length in pixels below which a segment is dropped, used by <i>StrokeAlysis</i>
    <li><b>float absoluteAngleFilterThreshold (default 0.22)</b>. Angle in radians, below which a bent segment is considered straight, used by <i>StrokeAlysis</i>
    <li><b>float minimumContourResampleSegment (default 1.0)</b>. Smallest size segment used when resampling the original contour. this prevents a fair amount of degeneracy in the resampled results, used by <i>StrokeAlysis</i>
    <li><b>float straightSegmentTangleThresh (default 0.1)</b> Threshold constant used by <i>Stroke.classifySegment</i>
        for a tangent angle (scaled to the range [0,1]) of a segment to be considered "straight".
    <li><b>float slowSegmentTangleThresh (default 0.3)</b> Threshold constant used by <i>Stroke.classifySegment</i>
        for a tangent angle (scaled to the range [0,1]) of a segment to be considered "a medium curve".
    <li><b>float sharpSegmentTangleThresh (default 0.9)</b> Threshold constant used by <i>Stroke.classifySegment</i>
        for a tangent angle (scaled to the range [0,1]) of a segment to be considered "a sharp curve".
   </ul>
</body>
</html>